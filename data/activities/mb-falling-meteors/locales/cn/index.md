### 你会做什么
在这个项目中，你将利用micro:bit创建一个游戏。通过micro:bit的两个按钮，玩家将移动防护罩来拦截坠落的流星并拯救地球。

<video controls="" width="500">
  <source src="https://gpblocks.org/hourOfCode2018/microbitGame/MeteorGame.mp4" type="video/mp4">
Movie showing Falling Meteors Game
</video>

你在这个项目中学到的技术可以用来为micro:bit制作许多其他游戏，包括Pong和Space Invaders等经典游戏。

### 你应该知道的

那些熟悉像 Scratch 这样的积木语言，并且使用过 *重复执行* 积木、*如果* 积木和变量的人会在这个项目上感到很自如。

鼓励那些从未编程过的人尝试这个项目。这很好玩，手把手的指南逐步地解释代码是如何工作的。

经验丰富的编码人员可以跳过开头，照着“把全部脚本汇总在一起”一节中给出的脚本编写程序，以尽快写好并运行他们的游戏。然后，探索本文末尾的*改进*措施或提出自己的改进措施。

### 你需要什么

你需要一个micro:bit：

![A micro:bit board](microbit.png =500x*)

您还需要一台带有USB接口的计算机，一根USB电缆将micro:bit连接到计算机，以及Microblocks软件（免费！）。

### 制作过程

#### 第1步：创建防护罩

在这个游戏中，玩家将使用A按钮和B按钮来回移动防护罩，以保护地球免受流星坠落的伤害。防护罩是 5x5 LED 显示屏中的一个点亮的LED小灯。防护罩始终处于底部一行内，但我们需要跟踪它在底部一行内的具体位置。底部一行的LED小灯从左到右编号为 1 到 5。我们将使用一个变量来跟踪防护罩的位置。

[[note]]
#### 什么是变量？

在编程中，变量用于记住值，以便以后可以使用它。带有变量名称的圆角积木可以插入任何允许插入值的积木内。例如，如果你有一个 *分数* 变量，你可以把它与“ *说* 积木”一起使用：

![输出分数](shuo-fenshu.png)

你可以使用*增加变量值*积木把分数变量的值加1：

![增加变量的值](ba-fenshu-jia-1.png)

你可以使用*设置变量值”积木把分数设为0：

![分数变量设为0](ba-fenshu-shewei-0.png)

当你的micro:bit连接到Microblocks之后，单击变量（即有变量名称的圆角积木），就会看到变量的值。显示变量值的气泡框将出现在变量积木的右上角。

![变量的气泡框](bianliang-qipao.png)

如果你不熟悉变量，不用急，后面我们会看到变量是如何使用的。
[[/note]]

要创建变量，请单击Microblocks窗口左侧的 *变量*类别，然后单击 *新建一个变量* 按钮。

Microblocks会要求输入变量的名字。在弹出的窗口内输入*防护罩位置*，然后单击确认按钮。

新的 *防护罩位置* 积木会出现在 *变量* 积木类别内。你将使用这块积木来记录防护罩的位置是多少。单击这块积木，看看变量的值现在是多少：

![防护罩位置](fanghuzhao-weizhi-qipao.png)

[[note]]
#### 遇到问题？

如果你单击 *防护罩位置* 变量后，没有看到气泡框，那么说明存在问题。你可以尝试采取下面的措施。

检查你的micro:bit板子有没有成功连上Microblocks。窗口上部的USB图标应当被绿色圆圈包围。如果圆圈是灰色的，那么micro:bit板子没有成功连上Microblocks，你要检查：（1）有没有为micro:bit烧录固件；（2）有没有用USB线把micro:bit与电脑连起来；（3）所使用的USB线是不是坏了，或者USB线只能供电不能传输数据。
[[/note]]

现在，添加一个脚本以使防护罩出现在 LED 显示屏上。拖放积木并组装成如下所示的脚本：

![显示防护罩](xianshi-fanghuzhao-step-1.png)

你单击窗口右上角的绿色箭头，这组脚本代码就会执行。脚本四周出现绿色光晕，表明脚本正在运行。

只要脚本是对的，脚本运行起来后，底部一行中间位置的LED小灯亮起来了：

![The shield showing up in the micro:bit](shield.jpg =250x*)

#### 第2步：移动防护罩

从 *变量* 积木类别中拖拉一个 *把...增加1* 积木，单击这块积木的下拉框，选择 *防护罩位置* 。

![“防护罩位置”增加1](ba-weizhi-zengjia-1.png)

如果你的脚本正在运行，你将看到亮起的LED灯向右移动一格。你可以用这个办法制作一个脚本，其作用是在按下 B 按钮时将防护罩向右移动：

![Moving the shield with button B](b-button-weizhi-zengjia-1.png)

写好上述脚本之后，单击Microblocks窗口的绿色箭头，然后用手按下micro:bit板子上的B按钮（右侧的那个）。亮起的LED灯将向右移动。耶！

但是，等一下——亮起的LED小灯向右移动几步后，它消失了！看起来这个程序有bug（毛病）。

[[note]]
#### 调试
别担心。即使是最有经验的程序员也会写出有bug的程序。找出和修复bug是编程的一个组成部分，就像修正拼写和语法错误是写文章的一部分一样。调试会是好玩的！你像一个侦探一样寻找线索，也像一个科学家那样做实验以对bug有更多了解。
[[/note]]

本例中，单击 *防护罩位置* 积木会呈现一个有价值的线索：

![调试位置值](tiaoshi-weizhi-6.png)

变量的值大于5。由于micro:bit板子的LED显示屏的一行只有5个LED灯，于是防护罩移到右边界之外去了。为了验证这一点，把 *防护罩位置* 变量的值设为1到5之间的数值：

![Setting "shield x" to 1](tiaoshi-fhz-weizhi-shewei-1.png)

亮起的LED灯会再次出现。单击窗口右上角的绿色箭头也会使得它再次出现，因为 *启动* 积木下的积木把 *防护罩位置* 变量的值设为3。

为了修正前面提及的bug，我们使用 *如果* 积木做到下面的事情：仅当防护罩不出界的情况下，防护罩才会向右移动。

![Only increment "shield x" if it's lower than 5](if-fhz-buchujie.png)

现在，编写一个相似的脚本，其作用是按下A按钮时，防护罩向左移动。

![Button A moves the shield to the left](a-btn-fhz-move-left.png)

编写上述脚本的快捷办法是复制 *当按键B被按下* 开头的脚本。鼠标右键单击 *当按键B被按下* 积木的上端，选择 *复制全部* 菜单项。

注意， *当按键A被按下* 开头的脚本是 *当按键B被按下* 开头的脚本的镜像版本。它将防护罩位置增加-1（也即减一），*if*积木 确保防护罩位置大于1；也就是说，防护罩有向左移动一步的余地，移动后不会出界。

在micro:bit板子上按下A按钮或者B按钮，可验证防护罩会向左或向右移动。防护罩不会出界，即使你尝试把它移出界。

目前一切顺利。但是，防护罩的移动速度太慢，不足以拦截快速下落的流星。

要加快防护罩移动速度，需要把 *等待500毫秒* 积木内的数字变小，比如50或者100。需要注意的是，如果你把数字变得太小，比如5，那么防护罩从一端移到另一端太快了，把它停在中间某个位置将变得困难。你可以反复试验，找出适合你自己的等待时长。

#### 第3步：添加坠落的流星

让我们添加一个从LED显示屏顶部开始并落下的流星。像防护罩一样，流星需要一个变量来跟踪其从左到右的位置（即列号）。它还需要一个变量来跟踪其从上到下的位置（即行号）。使用添加变量按钮添加两个新变量：*流星列号* 和 *流星行号* 。您最终会得到三个变量：

!["防护罩位置"变量](fhz-weizhi-bianliang.png) ![流星列号变量](liuxing-liehao-var.png) ![The "meteor y" variable](liuxing-hanghao-var.png)

现在，添加下面的脚本使得流星下落：

![Meteor fall script](liuxing-zhuiluo-1ci.png)

上述脚本把流星的列号设置为1（最左端）到5（最右端）之间的随机数。*流星行号* 变量设置为0，使得流星从LED显示屏的顶部出发。（LED显示屏顶部到底部，行号从1变到5。）*重复执行* 积木包裹的积木每过200毫秒（即0.2秒），把 *流星行号* 变量值加1，使得流星向下移动一行。等待200毫秒的目的是不让流星下落太快。修改等待时间的长度将改变流星的下落速度。

现在，在显示防护罩的脚本内添加显示流星的积木。

![Drawing both the shield and the meteor](xianshi-liuxing.png)

为了验证修改的脚本正常工作，单击Microblocks窗口的绿色箭头，你会看到一颗流星在显示屏顶部出现，接着向下移动直至在最底部一行消失。多次单击Microblocks窗口的绿色箭头运行脚本，你能注意到流星在顶部的出现位置是不固定的。

然而，上述脚本存在一个问题。我们不希望游戏在出现一颗流星后就结束。我们想要的是，只要玩家能够挡住流星坠落到底，就会不断出现下一颗流星。为了修正这个问题，我们用 *如果* 积木判断流星是否已经出界。一旦出界，就让它再次在显示屏顶部出现。

![Resetting the meteor position](liuxing-kongzhi-reset.png)

[[note]]
####  在多种解决方案之间进行选择
为什么脚本将 *流星行号* 与7进行比较？毕竟，一旦 *流星行号* 大于5，流星就会出界。

使这个数字比5大一点，在上一颗流星消失和下一颗流星出现之间留下一点停顿。使用 *等待...毫秒* 积木可以实现相同的效果。通常有很多方法可以解决同一个的问题，编程的创造性环节之一是决定使用哪种解决方案。
[[/note]]

把上述 *如果* 积木插入到控制流星坠落的脚本内：

![The complete meteor fall script](liuxing-kongzhi-chongfu.png)

点击Microblocks窗口右上角绿色箭头，运行当前版本的代码，看看效果是否如你所愿。

#### 第4步：添加冲突检测功能

现在，游戏有两项功能，一是通过按下micro:bit上的按钮移动防护罩，二是流星不断坠落。不过，当流星撞击到防护罩的时候，什么都没有发生。此时需要实现游戏开发者所讲的“冲突检测”功能。

我们如何检测到防护罩挡住了一颗流星？两个条件要成立。第一个条件是，流星到达显示屏的底部：

![meteor y = 5](liuxing-hanghao-dengyu-5.png)

第二个条件是，防护罩和流星要在同一列。

![meteor x = shield x](liuxing-liehao-dengyu-fhz-liehao.png)

用 *而且* 积木把这两个条件合并起来：

![Collision condition](jiance-liuxing-fhz-pengzhuan.png)

上述 *而且* 积木填入 *如果* 积木内，一旦检测到流星撞击到防护罩，就显示星耀效果：

![Drawing an explosion](pengzhuan-xingyao.png)

把上述 *如果* 积木加入显示防护罩和流星的脚本内：

![Complete drawing script](xianshi-fhz-liuxing-xingyao.png)

#### 把全部脚本汇总在一起

恭喜你完成了游戏开发任务。现在你已经是一个有经验的micro:bit游戏开发者。

下面是整个游戏程序的全部脚本代码：

![Final program](zhuiluo-liuxing-all-scripts.png)

单击窗口右上角的绿色箭头（即开始按钮），试玩游戏看看。在玩游戏过程中，留心游戏是偏难还是偏容易。流行的坠落速度是不是合适，有挑战但不至于无法拦截？防护罩移动速度是否合适？如果不合适，需要怎么修改以达到你期望的效果？

### 下一步工作

你可以断开micro:bit与电脑之间的连接。为micro:bit连上一块电池，你能在任何地方玩这个游戏。

和你的朋友比一比，看看谁能够拦截更多的流星！

### 改进措施

查看下面的“改进”想法，了解你可以添加的额外功能，或者你可以想出自己的改进措施。甚至，你可以运用你学到的知识开发其他游戏的micro:bit版本，比如Pong或Space Invaders。

#### 改进1：判断游戏结束

当玩家多次没有拦截到流星的时候，游戏结束。做到这一点是很棒的。下面是做到它的一种办法。

新建一个名字叫做 *遗漏数目* 变量。在游戏开始之际，用一块积木把 *遗漏数目* 变量设为0。把这块积木加到显示防护罩和流星的脚本内。

现在，把另一块 *如果* 积木加到显示防护罩和流星的脚本内：

![Endgame condition](yilou-shumu-end-game.png)

当玩家没能拦到一颗流星，上述脚本代码把 *遗漏数目* 变量加1。同时，也把 *流星行号* 加1——这避免在没能拦到流星时这段代码运行多次。最后，如果 *遗漏数目* 大于3，这段代码在显示屏上显示“X”，并结束游戏。下面是修改后的显示防护罩和流星的脚本。

![Draw script with endgame](game-gaijin-1.png)

#### 改进2：记录分数

你该如何记录玩家拦截了多少颗流星？是的，用另外一个变量——分数变量！记住，在游戏开始之际，把分数变量设为0。当游戏结束的时候，显示一个与分数对应的图案，告诉玩家玩得有多好。例如，如果玩家得分超过10分，显示一个笑脸图案。

#### 改进3：增加难度

使游戏更难的一种方法是让流星下落得更快。你能弄清楚哪个 *等待...毫秒* 积木控制流星坠落的速度吗？尝试不同的数字，看看你能以多快的速度让流星坠落，并且仍然能够抓住它们。

如果你添加了 *分数* 变量，也许你可以做到下面一点：随着玩家得分越来越高，流星坠落速度越来越快。
